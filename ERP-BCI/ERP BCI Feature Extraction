#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ERP-BCI Feature Extraction (from Colab notebook)

Pipeline:
- Load X_train.npy, X_test.npy, Y_train.npy, Y_test.npy
- Ensure data shaped as (n_epochs, n_channels, n_times)
- RandomOverSampler with sampling_strategy=0.5 on both train and test (to mirror notebook)
- Extract features with mne-features:
    mean, variance, std
    higuchi_fd, hurst_exp
    spect_entropy, ptp_amp
    wavelet_coef_energy
- Riemann features via XdawnCovariances + TangentSpace (pyriemann)
- Concatenate all blocks (48 + 32 + 32 + 48 + 136 = 296 dims)
- Save full feature matrices to "Linear and Non Linear Features"
- Also save the XDawn-only features (136 dims) to "XDawn"

Usage example:
    python erp_bci_feature_extraction.py \
        --data-dir . \
        --out-linear "Linear and Non Linear Features" \
        --out-xdawn "XDawn" \
        --sfreq 128 \
        --oversample 0.5
"""

import os
import argparse
import numpy as np

from imblearn.over_sampling import RandomOverSampler
from mne_features.feature_extraction import extract_features
from pyriemann.estimation import XdawnCovariances
from pyriemann.tangentspace import TangentSpace


# ------------------------- helpers -------------------------

def load_arrays(data_dir: str):
    def _p(name): return os.path.join(data_dir, f"{name}.npy")
    req = ["X_train", "X_test", "Y_train", "Y_test"]
    for r in req:
        path = _p(r)
        if not os.path.isfile(path):
            raise FileNotFoundError(f"Missing required file: {path}")

    X_train = np.load(_p("X_train"), allow_pickle=True)
    X_test  = np.load(_p("X_test"),  allow_pickle=True)
    Y_train = np.load(_p("Y_train"), allow_pickle=True).reshape(-1).astype(str)
    Y_test  = np.load(_p("Y_test"),  allow_pickle=True).reshape(-1).astype(str)
    return X_train, X_test, Y_train, Y_test


def ensure_nct(X: np.ndarray) -> np.ndarray:
    """
    Ensure shape is (n_epochs, n_channels, n_times).
    Assumes channels is the smaller of the last two dims if ambiguous.
    """
    if X.ndim != 3:
        raise ValueError(f"Expected 3D array, got shape {X.shape}")
    n, a, b = X.shape
    # If a <= b, treat 'a' as channels; else swap
    return X if a <= b else n
