#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
XDawn + XGBoost training and Optuna tuning (converted from notebook)

- Loads X_train, X_test (NumPy .npy) and y_train (NumPy .npy), y_test (CSV).
- Trains a baseline XGBClassifier with scale_pos_weight.
- Evaluates and prints classification report + confusion matrix.
- Runs Optuna hyperparameter search (timeout=600 seconds).
- Re-trains an XGB model with the best trial params and evaluates it.
- Saves Optuna visualization plots to HTML files in the working directory.

Note: Paths point to the original Colab Drive locations; change them if needed.
"""

import os
import sys
import time
import warnings
from typing import Tuple

import numpy as np
import pandas as pd

from sklearn.metrics import (
    classification_report,
    confusion_matrix,
)
from sklearn.model_selection import cross_val_score

# XGBoost
from xgboost import XGBClassifier

# Optuna (install if missing, to mirror the notebook's `pip install optuna`)
try:
    import optuna
    from optuna import Trial, visualization
    from optuna.samplers import TPESampler
except ImportError:  # pragma: no cover
    import subprocess

    subprocess.check_call([sys.executable, "-m", "pip", "install", "optuna"])
    import optuna
    from optuna import Trial, visualization
    from optuna.samplers import TPESampler


# ----------------------------
# Configuration (edit paths if needed)
# ----------------------------
X_TEST_PATH = "/content/drive/MyDrive/2021_VIIT08_P300/Dataset/bci-ner/XDAWN/X_test.npy"
X_TRAIN_PATH = "/content/drive/MyDrive/2021_VIIT08_P300/Dataset/bci-ner/XDAWN/X_train.npy"
Y_TRAIN_PATH = "/content/drive/MyDrive/2021_VIIT08_P300/Dataset/bci-ner/Y_train.npy"
Y_TEST_CSV_PATH = "/content/drive/MyDrive/2021_VIIT08_P300/Dataset/bci-ner/true_labels.csv"

OPTUNA_TIMEOUT_SEC = 600  # same as the notebook


def load_data() -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Load train/test arrays following the notebook logic."""
    X_test = np.load(X_TEST_PATH)
    X_train = np.load(X_TRAIN_PATH)
    y_train = np.load(Y_TRAIN_PATH)
    # Notebook loads CSV (no header) and reshapes to (3400,)
    y_test = np.reshape(pd.read_csv(Y_TEST_CSV_PATH, header=None).values, (-1,))
    return X_train, X_test, y_train, y_test


def compute_class_weight(y_train: np.ndarray) -> float:
    """Compute positive class weight as in the notebook."""
    pos = np.sum(y_train)
    neg = y_train.shape[0] - pos
    # Avoid division by zero
    if pos == 0:
        return 1.0
    return neg / pos


def evaluate_and_print(y_true: np.ndarray, y_pred: np.ndarray, title: str) -> None:
    print(f"\n===== {title} =====")
    print(classification_report(y_true, y_pred))
    print("------------Confusion Matrix---------------")
    print(confusion_matrix(y_true, y_pred))


def main() -> None:
    warnings.filterwarnings("ignore")
    np.set_printoptions(linewidth=120)

    # Load data
    X_train, X_test, y_train, y_test = load_data()
    print("Shapes:", X_test.shape, X_train.shape, y_train.shape, y_test.shape)

    # Class weight for imbalance
    cls_weight = compute_class_weight(y_train)
    print(f"Computed scale_pos_weight: {cls_weight}")

    # ----------------------------
    # Baseline XGBoost fit
    # ----------------------------
    print("\nFitting baseline XGBClassifier ...")
    baseline = XGBClassifier(scale_pos_weight=cls_weight)
    baseline.fit(X_train, y_train)
    y_pred_base = baseline.predict(X_test)
    evaluate_and_print(y_test, y_pred_base, "Baseline XGBoost")

    # ----------------------------
    # Optuna Hyperparameter Tuning
    # ----------------------------
    print("\nStarting Optuna study (maximize cross_val_score on test split; timeout ="
          f" {OPTUNA_TIMEOUT_SEC}s) ...")

    # Define objective mirroring the notebook (uses X_train/y_train for a pre-fit,
    # then cross_val_score on X_test/y_test).
    def objective(trial: Trial) -> float:
        param = {
            "n_estimators": trial.suggest_int("n_estimators", 0, 100),
            "max_depth": trial.suggest_int("max_depth", 2, 25),
            "min_child_weight": trial.suggest_int("min_child_weight", 0, 5),
            "gamma": trial.suggest_int("gamma", 0, 5),
            "learning_rate": trial.suggest_float("learning_rate", 0.005, 0.5, log=True),
            "nthread": -1,  # to mirror the notebook's XGBoost param
            # Note: we intentionally do NOT set scale_pos_weight in the objective,
            # because the original notebook didn't either during tuning.
        }

        model = XGBClassifier(**param)
        # Notebook fit (redundant for cross_val_score, but kept for fidelity)
        model.fit(X_train, y_train)

        # As in the notebook: evaluate on X_test / y_test via CV
        # (This is not a typical split, but matches the original cells.)
        score = cross_val_score(model, X_test, y_test).mean()
        return score

    study = optuna.create_study(direction="maximize", sampler=TPESampler())
    study.optimize(objective, timeout=OPTUNA_TIMEOUT_SEC)

    print(f"\nBest trial: score {study.best_trial.value},\nparams {study.best_trial.params}")

    # Optional: show trials dataframe head, like the notebook
    hist = study.trials_dataframe()
    try:
        print("\nTrials (head):")
        print(hist.head().to_string(index=False))
    except Exception:
        pass

    # ----------------------------
    # Refit with best params (+ scale_pos_weight) and evaluate
    # ----------------------------
    print("\nRefitting XGBClassifier with best params + scale_pos_weight ...")
    best_model = XGBClassifier(scale_pos_weight=cls_weight, **study.best_trial.params)
    best_model.fit(X_train, y_train)
    y_pred_best = best_model.predict(X_test)
    evaluate_and_print(y_test, y_pred_best, "XGBoost (Optuna best params)")

    # ----------------------------
    # Save Optuna plots to HTML (to mirror the visualization cells)
    # ----------------------------
    print("\nSaving Optuna visualization plots to HTML ...")
    try:
        fig_hist = visualization.plot_optimization_history(study)
        fig_hist.write_html("optuna_optimization_history.html", include_plotlyjs="cdn")
        print("  - optuna_optimization_history.html")

        fig_slice = visualization.plot_slice(study)
        fig_slice.write_html("optuna_slice.html", include_plotlyjs="cdn")
        print("  - optuna_slice.html")

        fig_importance = visualization.plot_param_importances(study)
        fig_importance.write_html("optuna_param_importances.html", include_plotlyjs="cdn")
        print("  - optuna_param_importances.html")
    except Exception as e:
        print("Could not generate/supply Optuna plots:", repr(e))

    print("\nDone.")


if __name__ == "__main__":
    main()
